"use strict";(self.webpackChunkspec_website=self.webpackChunkspec_website||[]).push([[695],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),f=r,m=h["".concat(c,".").concat(f)]||h[f]||d[f]||a;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=f;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},2991:(e,t,n)=>{n.d(t,{Z:()=>g});var o=n(7294),r=n(6010),a=n(2802),i=n(9960),s=n(3919),c=n(5999),l=n(2503);const p={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};function h(e){let{href:t,children:n}=e;return o.createElement(i.Z,{href:t,className:(0,r.Z)("card padding--lg",p.cardContainer)},n)}function d(e){let{href:t,icon:n,title:a,description:i}=e;return o.createElement(h,{href:t},o.createElement(l.Z,{as:"h2",className:(0,r.Z)("text--truncate",p.cardTitle),title:a},n," ",a),i&&o.createElement("p",{className:(0,r.Z)("text--truncate",p.cardDescription),title:i},i))}function f(e){let{item:t}=e;const n=(0,a.LM)(t);return n?o.createElement(d,{href:n,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:t.description??(0,c.I)({message:"{count} items",id:"theme.docs.DocCard.categoryDescription",description:"The default description for a category card in the generated index about how many items this category includes"},{count:t.items.length})}):null}function m(e){let{item:t}=e;const n=(0,s.Z)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",r=(0,a.xz)(t.docId??void 0);return o.createElement(d,{href:t.href,icon:n,title:t.label,description:t.description??r?.description})}function u(e){let{item:t}=e;switch(t.type){case"link":return o.createElement(m,{item:t});case"category":return o.createElement(f,{item:t});default:throw new Error(`unknown item type ${JSON.stringify(t)}`)}}function y(e){let{className:t}=e;const n=(0,a.jA)();return o.createElement(g,{items:n.items,className:t})}function g(e){const{items:t,className:n}=e;if(!t)return o.createElement(y,e);const i=(0,a.MN)(t);return o.createElement("section",{className:(0,r.Z)("row",n)},i.map(((e,t)=>o.createElement("article",{key:t,className:"col col--6 margin-bottom--lg"},o.createElement(u,{item:e})))))}},2892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var o=n(7462),r=(n(7294),n(3905)),a=n(2991);const i={title:"Polkadot Host"},s=void 0,c={unversionedId:"part-polkadot-host",id:"part-polkadot-host",title:"Polkadot Host",description:"With the current document, we aim to specify the Polkadot Host part of the Polkadot protocol as a replicated state machine. After defining the different types of hosts in Chapter 1, we proceed to specify the representation of a valid state of the Protocol in Chapter 2. We also identify the protocol states by explaining the Polkadot state transition and discussing the detail based on which the Polkadot Host interacts with the state transition function, i.e., Runtime, in the same chapter. Following, we specify the input messages triggering the state transition and the system behavior. In Chapter 4, we specify the communication protocols and network messages required for the Polkadot Host to communicate with other nodes in the network, such as exchanging blocks and consensus messages. In Chapter 5 and Chapter 6, we specify the consensus protocol, which is responsible for keeping all the replicas in the same state. Finally, the initial state of the machine is identified and discussed in Section A.3.3.. A Polkadot Host implementation that conforms with this part of the specification should successfully be able to sync its states with the Polkadot network.",source:"@site/docs/part-polkadot-host.md",sourceDirName:".",slug:"/part-polkadot-host",permalink:"/part-polkadot-host",draft:!1,unlisted:!1,editUrl:"https://github.com/w3f/polkadot-spec/blob/main/docs/part-polkadot-host.md",tags:[],version:"current",frontMatter:{title:"Polkadot Host"},sidebar:"tutorialSidebar",previous:{title:"Polkadot Protocol",permalink:"/id-polkadot-protocol"},next:{title:"1. Overview",permalink:"/chap-overview"}},l={},p=[],h={toc:p},d="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"With the current document, we aim to specify the Polkadot Host part of the Polkadot protocol as a replicated state machine. After defining the different types of hosts in ",(0,r.kt)("a",{parentName:"p",href:"chap-overview"},"Chapter 1"),", we proceed to specify the representation of a valid state of the Protocol in ",(0,r.kt)("a",{parentName:"p",href:"chap-state"},"Chapter 2"),". We also identify the protocol states by explaining the Polkadot state transition and discussing the detail based on which the Polkadot Host interacts with the state transition function, i.e., Runtime, in the same chapter. Following, we specify the input messages triggering the state transition and the system behavior. In ",(0,r.kt)("a",{parentName:"p",href:"chap-networking"},"Chapter 4"),", we specify the communication protocols and network messages required for the Polkadot Host to communicate with other nodes in the network, such as exchanging blocks and consensus messages. In ",(0,r.kt)("a",{parentName:"p",href:"sect-block-production"},"Chapter 5")," and ",(0,r.kt)("a",{parentName:"p",href:"sect-finality"},"Chapter 6"),", we specify the consensus protocol, which is responsible for keeping all the replicas in the same state. Finally, the initial state of the machine is identified and discussed in ",(0,r.kt)("a",{parentName:"p",href:"id-cryptography-encoding#section-genesis"},"Section A.3.3."),". A Polkadot Host implementation that conforms with this part of the specification should successfully be able to sync its states with the Polkadot network."),(0,r.kt)(a.Z,{mdxType:"DocCardList"}))}f.isMDXComponent=!0}}]);